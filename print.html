<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>raspberrypi-os-tutorials-notes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="arm_asm.html"><strong aria-hidden="true">2.</strong> ARM 汇编基础</a></li><li class="chapter-item expanded "><a href="chapter_0.html"><strong aria-hidden="true">3.</strong> 00: 准备工作</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">4.</strong> 01: wait_forever </a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">raspberrypi-os-tutorials-notes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#学习笔记--用-树莓派4-写嵌入式操作系统" id="学习笔记--用-树莓派4-写嵌入式操作系统">学习笔记 | 用 树莓派4 写嵌入式操作系统</a></h1>
<p>这是我对官方 <a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Operating System development tutorials in Rust on the Raspberry Pi</a> 的学习笔记。</p>
<h1><a class="header" href="#arm-汇编基础" id="arm-汇编基础">ARM 汇编基础</a></h1>
<p>汇编语言源程序格式区别：</p>
<ul>
<li><code>.s</code>，操作: 汇编，不可以在这里面加入预处理的命令。</li>
<li><code>.S</code>，操作: 预处理 + 汇编，可以在这里面加入预处理的命令。</li>
<li><code>.o</code>，只编译不链接。</li>
</ul>
<pre><code>$ as program.s -o program.o
$ ld program.o -o program
</code></pre>
<h2><a class="header" href="#汇编语言本质" id="汇编语言本质">汇编语言本质</a></h2>
<p>使用助记符和缩写来编写能控制底层高低电平电路信号的二进制机器码（指令集）组合，就是汇编程序。这些助记符集合就叫汇编语言。使用汇编工具去将汇编语言转换成机器码的过程叫做汇编(assembling)。</p>
<p>指令集体系结构(Instruction Set Architecture, ISA)，简称体系结构或系统结构(architecture),它是软件和硬件之间接口的一个完整定义。 ISA定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，所处理的操作数存放的地址空间以及操作数类型。指令集架构是一个能为电路硬件翻译应用程序的一层抽象层。</p>
<h2><a class="header" href="#数据类型" id="数据类型">数据类型</a></h2>
<p>操作：<strong>载入（load）</strong> 和 <strong>存储（store）</strong></p>
<p>数据类型：有符号或无符号的 字/ 半字/ 字节。</p>
<pre><code class="language-c">ldr = Load Word
ldrh = Load unsigned Half Word
ldrsh = Load signed Half Word
ldrb = Load unsigned Byte
ldrsb = Load signed Bytes
​
str = Store Word
strh = Store unsigned Half Word
strsh = Store signed Half Word
strb = Store unsigned Byte
strsb = Store signed Byte
</code></pre>
<h3><a class="header" href="#字节序列" id="字节序列">字节序列</a></h3>
<p>查看内存的字节两种方式：<strong>小端模式（Little-Endian）</strong> 和 <strong>大端模式（Big-Endian）</strong>。</p>
<h3><a class="header" href="#arm-寄存器" id="arm-寄存器">ARM 寄存器</a></h3>
<p>共有 30 个 32 位通用寄存器。前 16 个寄存器（r0-15）可在用户级模式下访问，其他寄存器在特权软件执行中可用。</p>
<p>前 16 个寄存器可以分为两组：通用寄存器和特殊用途寄存器。</p>
<ul>
<li>
<p><code>R0-R12</code>：可用于常见操作期间存储临时值、指针（内存位置）等等。例如<code>R0</code>，在算术运算期间可以称为累加器，或用于存储调用的函数时返回的结果。<code>R7</code>在进行系统调用时非常有用，因为它存储了系统号，<code>R11</code>可帮助我们跟踪作为帧指针的堆栈上的边界（稍后将介绍）。此外，ARM上的函数调用约定函数的前四个参数存储在寄存器<code>r0-r3</code>中。</p>
</li>
<li>
<p><code>R13</code>：<code>SP</code>（栈指针）。始终指向当前栈顶。</p>
</li>
<li>
<p><code>R14</code>：<code>LR</code>（链接寄存器）。进行函数调用时，链接寄存器将更新为当前函数调用指令的下一个指令的地址，也就是函数调用返回后需要继续执行的指令。这么做是允许子函数调用完成后，在子函数中利用该寄存器保存的指令地址再返回到父函数中。</p>
</li>
<li>
<p><code>R15</code>：<code>PC</code>（程序计数器）。程序计数器自动按执行的指令大小递增。此指令大小在 ARM 模式下始终为4个字节，在 THUMB 模式下为 2 个字节。执行分支指令时，PC 保存目标地址。在执行过程中，在 ARM 模式下 PC 将当前指令的地址加上 8（两个ARM指令），在 Thumb（v1）状态下则指令加上4（两个Thumb指令）。这与x86 中 PC 始终指向要执行的下一个指令不同。</p>
</li>
</ul>
<h2><a class="header" href="#arm-模式-和-thumb-模式" id="arm-模式-和-thumb-模式">ARM 模式 和 Thumb 模式</a></h2>
<p>ARM 处理器主要有两种工作模式: ARM 状态 和 Thumb 状态。它们主要区别是指令集，在 ARM 模式下指令集始终是<code>32-bit</code>，但是在 Thumb 模式下可以是<code>16-bit</code>或者<code>32-bit</code>。学会怎么使用Thumb模式对于ARM开发很重要。</p>
<p><strong>ARM模式和Thumb模式的态区别：</strong></p>
<ul>
<li>条件执行：在 ARM 模式下所有的指令都支持条件执行。一些版本的ARM处理器可以通过it指令在Thumb工作模式下支持条件执行。</li>
<li>ARM 和 Thumb 模式下的32-bit指令：在 Thumb 模式下的<code>32-bit</code>指令有<code>.w</code>后缀。</li>
<li>桶型位移器（barrel shifter）是ARM模式下的另一个特点。它可以将多条指令缩减为一条。例如，你可以通过向左位移1位的指令后缀将乘法运算直接包含在一条MOV指令中（将一个寄存器的值乘以2，再将结果MOV到另一个寄存器）: <code>MOV R1, R0, LSL#1 ;R1 = R0 * 2</code>，而不需要使用专门的乘法指令来运算。</li>
</ul>
<h3><a class="header" href="#armv8-寄存器" id="armv8-寄存器">ARMv8 寄存器</a></h3>
<ul>
<li>
<p>参数寄存器（X0-X7）： 用作临时寄存器或可以保存的调用者保存的寄存器变量函数内的中间值，调用其他函数之间的值（8 个寄存器可用于传递参数）</p>
</li>
<li>
<p>来电保存的临时寄存器（X9-X15）： 如果调用者要求在任何这些寄存器中保留值调用另一个函数，调用者必须将受影响的寄存器保存在自己的堆栈中帧。 它们可以通过被调用的子程序进行修改，而无需保存并在返回调用者之前恢复它们。</p>
</li>
<li>
<p>被调用者保存的寄存器（X19-X29）： 这些寄存器保存在被调用者帧中。 它们可以被被调用者修改子程序，只要它们在返回之前保存并恢复。</p>
</li>
<li>
<p>特殊用途寄存器（X8，X16-X18，X29，X30）：</p>
<ul>
<li>X8： 是间接结果寄存器，用于保存子程序返回地址，尽量不使用</li>
<li>X16 和 X17： 程序内调用临时寄存器</li>
<li>X18： 平台寄存器，保留用于平台 ABI，尽量不使用</li>
<li>X29： 帧指针寄存器（FP）</li>
<li>X30： 链接寄存器（LR）</li>
<li>X31： 堆栈指针寄存器 SP 或零寄存器 ZXR</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#异常向量表" id="异常向量表">异常向量表</a></h3>
<p>在ARM体系结构中，存在7种异常处理。当异常发生时，处理器会把PC设置为一个特定的存储器地址。这一地址放在被称为向量表（vector table）的特定地址范围内，向量表的入口是一些跳转指令，跳转到专门处理某个异常或中断的子程序。</p>
<p>异常向量表地址说明：</p>
<ul>
<li><code>0x00</code>: 复位，进入 管理模式</li>
<li><code>0x04</code>: 未定义指令， 进入 未定义模式</li>
<li><code>0x08</code>: 软件中断，进入 管理模式</li>
<li><code>0x0c</code>: 中止（预取），进入 中止模式</li>
<li><code>0x10</code>: 中止（数据），进入 中止模式</li>
<li><code>0x14</code>: 保留</li>
<li><code>0x18</code>: 中断 IRQ ，进入 中断模式</li>
<li><code>0x1c</code>: 快中断 FIQ，进入 快中断模式</li>
</ul>
<h2><a class="header" href="#arm指令简介" id="arm指令简介">ARM指令简介</a></h2>
<p>ARM指令后面通常跟着两个操作数，像下面这样的形式：</p>
<pre><code class="language-text">MNEMONIC{S}{condition} {Rd}, Operand1, Operand2
</code></pre>
<p>解释：</p>
<pre><code class="language-text">MNEMONIC     - 操作指令（机器码对应的助记符）。
{S}          - 可选后缀. 如果指定了该后缀，那么条件标志将根据操作结果进行更新。
{condition}  - 执行指令所需满足的条件。
{Rd}         - 目标寄存器，存储操作结果。
Operand1     - 第一操作数（寄存器或者立即数）
Operand2     - 第二操作数. 立即数或者带有位移操作后缀（可选）的寄存器。
</code></pre>
<p><code>condition</code>字段与<code>CPSR</code>寄存器的值有关，准确的说是和<code>CPSR</code>某些位有关。<code>Operand2</code>也叫可变操作数，因为它可以有多种形式--立即数、寄存器、带有位移操作的寄存器。</p>
<p>例如<code>Operand2</code>可以有以下多种形式：</p>
<pre><code class="language-text">#123                    - 立即数。
Rx                      - 寄存器x (如 R1, R2, R3 ...)。
Rx, ASR n               - 寄存器x，算术右移n位 (1 = n = 32)。
Rx, LSL n               - 寄存器x，逻辑左移n位 (0 = n = 31)。
Rx, LSR n               - 寄存器x，逻辑右移n位 (1 = n = 32)。
Rx, ROR n               - 寄存器x，循环右移n位 (1 = n = 31)。
Rx, RRX                 - 寄存器x，扩展的循环位移，右移1位。
</code></pre>
<p>示例：</p>
<pre><code class="language-text">ADD   R0, R1, R2         - 将寄存器R1内的值与寄存器R2内的值相加，结果存储到R0。
ADD   R0, R1, #2         - 将寄存器R1内的值加上立即数2，结果存储到R0。
MOVLE R0, #5             - 仅当满足条件LE（小于或等于）时，才将立即数5移动到R0（编译器会把它看作MOVLE R0, R0, #5）。
MOV   R0, R1, LSL #1     - 将寄存器R1的内容向左移动一位然后移动到R0（Rd）。因此，如果R1值是2，它将向左移动一位，并变为4。然后将4移动到R0。
</code></pre>
<p>其他指令：</p>
<p><img src="./img/sets.png" alt="sets" /></p>
<h3><a class="header" href="#内存指令加载load和-存储stroe" id="内存指令加载load和-存储stroe">内存指令：加载（Load）和 存储（Stroe）</a></h3>
<p>在ARM上数据必须从内存中加载到寄存器之后才能进行其他操作，而在x86上大部分指令都可以直接访问内存中的数据。</p>
<p>你只能使用LDR和STR指令访问内存。</p>
<p>三个基本偏移形式：</p>
<ol>
<li>
<p>偏移形式：立即数作为偏移量</p>
<ul>
<li>寻址模式：立即寻址</li>
<li>寻址模式：前变址寻址</li>
<li>寻址模式：后变址寻址</li>
</ul>
</li>
<li>
<p>偏移形式：寄存器作为偏移量</p>
<ul>
<li>寻址模式：立即寻址</li>
<li>寻址模式：前变址寻址</li>
<li>寻址模式：后变址寻址</li>
</ul>
</li>
<li>
<p>偏移形式：缩放寄存器作为偏移量</p>
<ul>
<li>寻址模式：立即寻址</li>
<li>寻址模式：前变址寻址</li>
<li>寻址模式：后变址寻址</li>
</ul>
</li>
</ol>
<p>示例 1：</p>
<p><code>LDR</code> 用于将内存中的值加载到寄存器中，<code>STR</code> 用于将寄存器内的值存储到内存地址。</p>
<pre><code>LDR R2, [R0]   @ [R0] - R0中保存的值是源地址。
STR R2, [R1]   @ [R1] - R1中保存的值是目标地址。
</code></pre>
<ul>
<li>LDR : 把R0内保存的值作为地址值，将该地址处的值加载到寄存器R2中。</li>
<li>STR : 把R1内保存的值作为地址值，将寄存器R2中的值存储到该地址处。</li>
</ul>
<p>有时你想要更有效率，一次加载（或存储）多个值。为此我们可以使用<code>LDM（load multiple）</code>和<code>STM（stroe multiple）</code>指令。</p>
<h3><a class="header" href="#入栈和出栈" id="入栈和出栈">入栈和出栈</a></h3>
<p>进程中有一个叫做栈的内存位置。栈指针（<code>SP</code>）寄存器总是指向栈内存中的地址。程序应用中通常使用栈来存储临时数据。前面讲的ARM中只能使用加载和存储来访问内存，就是只能使用<code>LDR</code>/<code>STR</code>指令或者他们的衍生指令（<code>LDM</code>、<code>STM</code>、<code>LDMIA</code>、<code>LDMDA</code>、<code>STMDA</code>等等）进行内存操作。在x86中使用<code>PUSH</code>和<code>POP</code>从栈内取或存，ARM中我们也可以使用这条指令。</p>
<h3><a class="header" href="#条件状态和分支" id="条件状态和分支">条件状态和分支</a></h3>
<p>下面的表格列出了可用的条件状态码，描述和标志位：</p>
<p><img src="./img/if.png" alt="if" /></p>
<p>下面是条件代码和相反代码：</p>
<p><img src="./img/cmp.png" alt="cmp" /></p>
<p><strong>分支：</strong></p>
<p>有三种类型的分支指令：</p>
<ul>
<li>普通分支（B），简单的跳转到一个函数。</li>
<li>带链接的跳转（BL），将PC+4的值保存到LR寄存器，然后跳转。</li>
<li>带状态切换的跳转（BX）和带状态切换及链接的跳转（BLX），与B和BL一致，只是添加了工作状态的切换（ARM模式-Thumb模式）。需要寄存器作为第一个操作数。</li>
</ul>
<h3><a class="header" href="#栈和函数" id="栈和函数">栈和函数</a></h3>
<p>一般而言，栈就是进程中的一段内存。这段内存是在进程创建时分配的。我们使用栈来保存一些临时数据，如函数中的局部变量，函数之间转换的环境变量等。使用PUSH和POP指令与栈进行交互。</p>
<p>为了让一切变得井然有序，函数使用栈帧（专门用于函数中使用的局部内存区域）。栈帧是在函数开始调用时创建的。栈帧指针（FP）被置为栈帧的底部，然后分配栈帧的缓冲区。栈帧中通常（从底部）保存了返回地址（前面的LR寄存器值）、栈帧指针、其他一些需要保存的寄存器、函数参数（如果超过4个参数）、局部变量等等。虽然栈帧的实际内容可能有所不同，但基本就这些。最后栈帧在函数结束时被销毁。</p>
<p><strong>函数</strong></p>
<p>函数体的结构：开始、执行体和收尾。</p>
<p>开始时需要保存程序前面的状态（LR和R11分别入栈）然后为函数的局部变量设置堆栈。虽然开始部分的实现可能因编译器而异，但通常是用PUSH/ADD/SUB指令来完成的。大体看起来是下面这样：</p>
<pre><code class="language-text">push   {r11, lr}    /* 将lr和r11入栈 */
add    r11, sp, #0  /* 设置栈帧的底部位置 */
sub    sp, sp, #16  /* 栈指针减去16为局部变量分配缓存区 */
</code></pre>
<p>函数体部分就是你程序的实际逻辑区，包含了你代码逻辑的各种指令：</p>
<pre><code class="language-text">mov    r0, #1       /* 设置局部变量(a=1). 同时也为函数max的第一个参数 */
mov    r1, #2       /* 设置局部变量(b=2). 同时也为函数max的第二个参数 */
bl     max          /* 调用函数max */
</code></pre>
<p>函数的最后部分用于将程序的状态还原到它初始的状态（函数调用前），这样就可以从函数被调用的地方继续执行。所以我们需要重新调整栈指针（SP）。</p>
<p>重新调整栈指针后，将之前（函数开始处）保存的寄存器值从堆栈弹出到相应的寄存器来还原这些寄存器值。根据函数类型，一般POP指令是函数最后结束的指令。但是，在还原寄存器值后，我们需要使用 BX 指令来离开函数。示例如下：</p>
<pre><code class="language-text">sub    sp, r11, #0  /* 重新调整栈指针 */
pop    {r11, pc}    /* 恢复栈帧指针, 通过加载之前保存的LR到PC，程序跳转到之前LR保存位置。函数的栈帧被销毁 */
</code></pre>
<p>所以我们现在知道：</p>
<ol>
<li>函数在开始时设置相应的环境。</li>
<li>函数体中执行相关逻辑，然后通过R0保存返回值。</li>
<li>函数收尾时恢复所有的状态，以便程序可以在函数调用前的位置继续执行。</li>
</ol>
<p><strong>叶子函数和非叶子函数</strong></p>
<ul>
<li>叶子函数，在函数内不会调用/跳转到另一个函数。</li>
<li>非叶子函数，则会在自己的函数逻辑中调用另一个函数。</li>
</ul>
<h2><a class="header" href="#代码示例" id="代码示例">代码示例</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.section  .data         ; 这里.section常常省略
    &lt;初始化数据&gt;
.section  .bss          ; 这里.section常常省略
    &lt;未初始化数据&gt;
.section  .text         ; 这里.section常常省略
.global     __start     ; 如果其他文件调用__start，则需要.global声明
__start:                ; 标签，相当于函数入口
    &lt;汇编代码&gt;
<span class="boring">}
</span></code></pre></pre>
<p>寻址方式：</p>
<ul>
<li>立即数寻址。<code>ADD R0， R0， #0x3F</code></li>
<li>寄存器寻址。<code>ADD R0,  R1,  R2</code></li>
<li>寄存器间接寻址。<code>LDR R0, [R2]    ；相当于指针</code></li>
<li>基址变址寻址。<code>LDR R0, [R1, #4]</code></li>
<li>相对寻址。<code>BL  NECT    ；  NEXT为标签</code></li>
</ul>
<p>定义类伪指令：</p>
<ul>
<li><code>.global</code> 表明一个标号为全局</li>
<li><code>.ascii</code> 定义字符串数据</li>
<li><code>.byte</code> 定义字节数据</li>
<li><code>.word</code> 定义字数据</li>
<li><code>.data</code> 表明数据段</li>
<li><code>.size </code> 设定指定符号的大小</li>
<li><code>.type</code>  指定符号的类型</li>
</ul>
<pre><code>.data
varA:
.ascii  &quot;helloworld&quot;
varB:
.word   0xff
varC:
.byte   0x1
.text
    ...
</code></pre>
<p><code>.equ</code> 定义一个宏:</p>
<pre><code>.equ    DA, 0x89
mov r0, #DA
</code></pre>
<p><code>nop</code> 空操作</p>
<pre><code>mov r0, r0
</code></pre>
<p><code>wfi</code> 和 <code>wfe</code>:</p>
<p><code>wfi (Wait for interrupt)</code>和<code>wfe (Wait for event)</code>是两个让ARM核进入<code>low-power standby</code>模式的指令，由ARM architecture定义，由ARM core实现。<code>spinlock</code>实现一般和 <code>wfe</code>指令有关。</p>
<p>standby 一般为待机模式。</p>
<p>对WFI来说，执行WFI指令后，ARM core会立即进入low-power standby state，直到有WFI Wakeup events发生。</p>
<p>而WFE则稍微不同，执行WFE指令后，根据Event Register（一个单bit的寄存器，每个PE一个）的状态，有两种情况：如果Event Register为1，该指令会把它清零，然后执行完成（不会standby）；如果Event Register为0，和WFI类似，进入low-power standby state，直到有WFE Wakeup events发生。</p>
<p>跳转：</p>
<ul>
<li><code>b  1b</code> 中的b是backward的意思，跳到程序的前面（往上）</li>
<li><code>b  1f</code>  中的f是forward的意思，跳到程序的后面（往下）</li>
<li><code>1</code>表示标号（局部标号）。</li>
</ul>
<h3><a class="header" href="#参考" id="参考">参考</a></h3>
<ol>
<li><a href="https://www.zhihu.com/column/c_1215698269139152896">https://www.zhihu.com/column/c_1215698269139152896</a></li>
<li><a href="https://azeria-labs.com/writing-arm-assembly-part-1/">https://azeria-labs.com/writing-arm-assembly-part-1/</a></li>
<li><a href="http://blog.leanote.com/post/tarena/ARM%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8">http://blog.leanote.com/post/tarena/ARM%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8</a></li>
<li><a href="https://www.huaweicloud.com/articles/ca0de32c6bb0903b23de5dbcdfab3c5b.html">https://www.huaweicloud.com/articles/ca0de32c6bb0903b23de5dbcdfab3c5b.html</a></li>
</ol>
<h1><a class="header" href="#00-准备工作" id="00-准备工作">00: 准备工作</a></h1>
<p>因为国内的环境，需要对原来的 Dockerfile 和 命令做一些更改。</p>
<h2><a class="header" href="#更改-dockerfile" id="更改-dockerfile">更改 Dockerfile</a></h2>
<p>打开 <code>docker/rustembedded-osdev-utils/Dockerfile</code>，找到<code># QEMU</code>，更改 <code>git</code> 地址为下面这行：</p>
<pre><code># QEMU
git clone https://git.qemu.org/git/qemu.git;    
</code></pre>
<h2><a class="header" href="#更改-makefile-中-docker-命令" id="更改-makefile-中-docker-命令">更改 Makefile 中 Docker 命令</a></h2>
<p><code>docker build</code> 命令下要添加这一行：</p>
<pre><code>  --add-host raw.githubusercontent.com:185.199.111.133 \
</code></pre>
<p>这是为了避免无法解析 <code>raw.githubusercontent.com</code> 域名而为，IP地址如果不行，则请自行<code>ping</code>获取最新的。</p>
<h2><a class="header" href="#构建本地-docker-镜像" id="构建本地-docker-镜像">构建本地 Docker 镜像</a></h2>
<p>进入 <code>docker</code> 目录，执行命令：</p>
<pre><code>&gt; make
</code></pre>
<p>即可。</p>
<h2><a class="header" href="#教程说明" id="教程说明">教程说明</a></h2>
<p>包含一个独立可引导的二进制内核文件。前五章只能使用 Qemu 来运行，因为都是基础内容。到了第六章可以在树莓派上加载和运行内核并通过UART来观察输出结果。</p>
<h3><a class="header" href="#代码组织和结构" id="代码组织和结构">代码组织和结构</a></h3>
<ul>
<li>
<p><code>src/_arch</code>。针对特定目标架构的内核子系统，放到该目录下。<code>_arch</code>中的<code>_</code>表示此文件夹不属于标准模块层次结构。而是使用<code>＃[path =&quot;_arch/xxx/yyy.rs&quot;]</code>属性将其内容有条件地引入各自的文件中。</p>
</li>
<li>
<p><code>bsp/</code>。 bsp 模块中定义 <code>BSP</code>， 表示 Board Support Package。而且包含目标主板特殊的定义和功能。这些是诸如主板的内存映射或相应主板上的设备驱动程序实例之类的东西。</p>
</li>
</ul>
<h3><a class="header" href="#内核接口" id="内核接口">内核接口</a></h3>
<p><code>arch</code>和<code>bsp</code>都包含根据实际目标和主板不同而编译的代码。例如，<code>interrupt controller</code>对于硬件<code>Raspberry Pi 3</code>和<code>Raspberry Pi 4</code>是不同的，但是我们想让<code>kernel</code>剩下的代码可以轻松地适配它们。</p>
<p>通过 trait 接口来对其进行抽象是个很好的做法。</p>
<pre><code class="language-text">        +-------------------+
        | Interface (Trait) |
        |                   |
        +--+-------------+--+
           ^             ^
           |             |
           |             |
+----------+--+       +--+----------+
| kernel code |       |  bsp code   |
|             |       |  arch code  |
+-------------+       +-------------+
</code></pre>
<h2><a class="header" href="#嵌入式操作系统特点" id="嵌入式操作系统特点">嵌入式操作系统特点</a></h2>
<p>嵌入式操作系统EOS（Embedded Operating System）是一种用途广泛的系统软件，过去它主要应用于工业控制和国防系统领域。EOS负责嵌入系统的全部软、硬件资源的分配、调度作，控制、协调并发活动；它必须体现其所在系统的特征，能够通过装卸某些模块来达到系统所要求的功能。</p>
<p>EOS是相对于一般操作系统而方的，它除具备了一般操作系统最基本的功能，如任务调度、同步机制、中断处理、文件处理等外，还有以下特点：</p>
<ul>
<li>可装卸性。开放性、可伸缩性的体系结构。</li>
<li>强实时性。EOS实时性一般较强，可用于各种设备控制当中。</li>
<li>统一的接口。提供各种设备驱动接口。</li>
<li>操作方便、简单、提供友好的图形GUI，图形界面，追求易学易用。</li>
<li>提供强大的网络功能，支持TCP/IP协议及其它协议，提供TCP/UDP/IP/PPP协议支持及统一的MAC访问层接口，为各种移动计算设备预留接口。</li>
<li>强稳定性，弱交互性。嵌入式系统一旦开始运行就不需要用户过多的干预，这就要负责系统管理的EOS具有较强的稳定性。嵌入式操作系统的用户接口一般不提供操作命令，它通过系统的调用命令向用户程序提供服务。</li>
<li>固化代码。在嵌入式系统中，嵌入式操作系统和应用软件被固化在嵌入式系统计算机的ROM中。辅助存储器在嵌入式系统中很少使用，因此，嵌入式操作系统的文件管理功能应该能够很容易地拆卸，而用各种内存文件系统。</li>
<li>更好的硬件适应性，也就是良好的移植性。</li>
</ul>
<blockquote>
<p>以上参考：<a href="https://www.jianshu.com/p/845a01816f2a">https://www.jianshu.com/p/845a01816f2a</a></p>
</blockquote>
<h2><a class="header" href="#树莓派简介" id="树莓派简介">树莓派简介</a></h2>
<p>因为手头有一个树莓派4b，吃灰一年了，现在就用它先来跟随这个教程实现一个嵌入式 OS 吧。</p>
<p>树莓派4b的核心处理器（SoC）为博通 BCM2711（四核1.5GHz，Cortex A72架构，树莓派3是四核A53），LPDDR4内存，由5V/3A USB-C供电或GPIO 5V。</p>
<p>树莓派上面可以安装的操作系统有很多：Raspbian/ Pidora/ Arch/ Kali Linux/ OSMC/ Ubuntu MATE/ Ubuntu Core/ Ubuntu Server/ LibreELEC/ Mozilla WebThings/ CentOS/ ChromiumOS 等等（参考：<a href="https://zhuanlan.zhihu.com/p/105299943">https://zhuanlan.zhihu.com/p/105299943</a>）。</p>
<p><img src="./img/pi4.png" alt="pi4" /></p>
<h3><a class="header" href="#arm-架构" id="arm-架构">ARM 架构</a></h3>
<ul>
<li>ARM 架构使用 精简指令集（RISC），而 x86 使用复杂指令集（CISC)。</li>
<li>ARM 处理器是低功耗处理器。</li>
<li>ARM 对应 ARMv8 64位架构，有两种执行模式 <code>AArch32</code> 和 <code>AArch64</code>。Intel 的 64位指令集 x86-64（有时简称为x64）实际是 AMD 设计开发的。</li>
</ul>
<h3><a class="header" href="#cortex-a72" id="cortex-a72">Cortex-A72</a></h3>
<p>树莓派4b采用的 Cortex-A72 是目前基于 ARMv8-A 架构处理器中使用最广泛的处理器之一，主要其应用市场包括高端智能手机、大屏幕的移动设备、企业网路设备、服务器、无线基台、数字电视。</p>
<h3><a class="header" href="#armv8-aarch64-寄存器和指令集" id="armv8-aarch64-寄存器和指令集">ARMv8-aarch64 寄存器和指令集</a></h3>
<p><strong>异常等级</strong></p>
<p>软件运行异常级别：</p>
<ul>
<li>EL0： 普通用户应用程序</li>
<li>EL1： 操作系统内核通常被描述为特权</li>
<li>EL2： 管理程序</li>
<li>EL3： 低级固件，包括安全监视器</li>
</ul>
<p><strong>ARMv8 寄存器</strong></p>
<p>AArch 拥有 31 个通用寄存器，系统运行在 64 位状态下的时候名字叫 Xn，运行在 32 位的时候就叫 Wn.</p>
<p><strong>ARM 64 位架构的 ABI</strong></p>
<p>ARM 体系结构的应用程序二进制接口（ABI， Application Binary Interface）指定了基本规则所有可执行的本机代码模块必须遵守，以便它们可以正常工作。</p>
<h2><a class="header" href="#arm-汇编语言基础" id="arm-汇编语言基础">ARM 汇编语言基础</a></h2>
<p><a href="./arm_asm.html">详细</a></p>
<p>参考：</p>
<ol>
<li><a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/arm/hardware/index.html">https://cloud-atlas.readthedocs.io/zh_CN/latest/arm/hardware/index.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21266987">https://zhuanlan.zhihu.com/p/21266987</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/95028674">https://zhuanlan.zhihu.com/p/95028674</a></li>
<li><a href="https://winddoing.github.io/post/7190.html">https://winddoing.github.io/post/7190.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/82490125">https://zhuanlan.zhihu.com/p/82490125</a></li>
</ol>
<h1><a class="header" href="#chapter-1-wait-forever" id="chapter-1-wait-forever">Chapter 1 ：Wait Forever</a></h1>
<p>这一章的内容很简单，就是构建了一个死循环。还没有任何内核代码。</p>
<h2><a class="header" href="#代码解释" id="代码解释">代码解释</a></h2>
<p>一、先看 <code>main.rs</code> ：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(asm)]
#![feature(global_asm)]
#![no_main]
#![no_std]

<span class="boring">fn main() {
</span>mod bsp;
mod cpu;
mod panic_wait;

// Kernel code coming next tutorial.
<span class="boring">}
</span></code></pre></pre>
<p>这段代码中，用到了两个 Feature Gate : <code>#![feature(asm)]</code> 和 <code>#![feature(global_asm)]</code>，只有Nightly Rust 下才可以用它们，这表示我们要使用内联汇编功能。</p>
<p>注意另外也用了 <code>#![no_main]</code> 和 <code>#![no_std]</code>，因为现在是面向 bare metal 编程，无法使用标准库。</p>
<p>二、 再看 <code>cpu</code> 模块：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cpu/boot.rs 
#[cfg(target_arch = &quot;aarch64&quot;)]
#[path = &quot;../_arch/aarch64/cpu/boot.rs&quot;]
mod arch_boot;
<span class="boring">}
</span></code></pre></pre>
<p>这个通过 <code>#[path = &quot;../_arch/aarch64/cpu/boot.rs&quot;]</code>来指定具体的模块路径，实际上是 <code>_arch/aarch64/cpu/boot.rs</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// _arch/aarch64/cpu/boot.rs

global_asm!(include_str!(&quot;boot.s&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>而这个 <code>boot.rs</code> 中则使用 <code>global_asm!</code> 来加载外部汇编源码文件<code>boot.s</code>。</p>
<p>三、 汇编代码释疑</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------
.section .text._start

//------------------------------------------------------------------------------
// fn _start()
//------------------------------------------------------------------------------
_start:
	// Infinitely wait for events (aka &quot;park the core&quot;).
1:	wfe         // 设置 标签 1，使用指令 wfe ，等待某个事件，让 ARM 核进入待机模式
	b	1b      // 跳转回 标签 1

.size	_start, . - _start 
.type	_start, function
.global	_start  
<span class="boring">}
</span></code></pre></pre>
<p>这段汇编代码是 ARM 汇编，结合相关汇编知识，我们可以看出，这段代码是将整个程序设置为待机模式。</p>
<p>此处穿插一些相关的 ARM 汇编基础：</p>
<blockquote>
<p><code>wfi</code> 和 <code>wfe</code>:</p>
<p><code>wfi (Wait for interrupt)</code>和<code>wfe (Wait for event)</code>是两个让ARM核进入<code>low-power standby</code>模式的指令，由ARM architecture定义，由ARM core实现。<code>spinlock</code>实现一般和 <code>wfe</code>指令有关。</p>
<p>standby 一般为待机模式。</p>
<p>对WFI来说，执行WFI指令后，ARM core会立即进入low-power standby state，直到有WFI Wakeup events发生。</p>
<p>而WFE则稍微不同，执行WFE指令后，根据Event Register（一个单bit的寄存器，每个PE一个）的状态，有两种情况：如果Event Register为1，该指令会把它清零，然后执行完成（不会standby）；如果Event Register为0，和WFI类似，进入low-power standby state，直到有WFE Wakeup events发生。</p>
</blockquote>
<p>四、 BSP</p>
<p>因为现在只能用 qemu，所以 BSP 就暂时无效。</p>
<p>五、 Panic Handler </p>
<p>在标准库中，Panic 已经被定义。但是在不使用标准库的 <code>no-std</code> 环境，Panic 属于未定义，所以我们需要定义它的行为。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// panic_wait.rs

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    unimplemented!()
}
<span class="boring">}
</span></code></pre></pre>
<p><code>＃[panic_handler]</code>用于定义恐慌的行为！在<code>＃！[no_std]</code>应用程序中。 <code>＃[panic_handler]</code>属性必须应用于签名为<code>fn（＆PanicInfo）-&gt; !</code> 的函数。 并且该函数必须在 <code>binary / dylib / cdylib</code> crate 的依赖关系图中出现一次。 </p>
<p>鉴于嵌入式系统的范围从用户面临的问题到对安全至关重要的问题（不会崩溃），没有一种大小适合所有恐慌行为，但是有很多常用行为。 这些常见行为已打包到定义<code>＃[panic_handler]</code>函数的 crate 中。 一些示例包括：</p>
<ul>
<li><a href="https://crates.io/crates/panic-abort">panic-abort</a> 。Panic 会导致执行中止（abort）指令。</li>
<li><a href="https://crates.io/crates/panic-halt">panic-halt</a> 。Panic 会导致程序或当前线程通过进入无限循环而暂停。</li>
<li><a href="https://crates.io/crates/panic-itm">panic-itm</a> 。Panic 消息是使用ITM（ARM Cortex-M特定的外围设备）记录的。</li>
<li><a href="https://crates.io/crates/panic-semihosting">panic-semihosting</a> 。Panic 消息将使用半主机（semihosting）技术记录到主机。</li>
</ul>
<blockquote>
<p>参考： <a href="https://docs.rust-embedded.org/book/start/panicking.html">https://docs.rust-embedded.org/book/start/panicking.html</a></p>
</blockquote>
<p>六、 <code>build.rs</code></p>
<pre><pre class="playground"><code class="language-rust">// build.rs
use std::env;

fn main() {
    let linker_file = env::var(&quot;LINKER_FILE&quot;).unwrap();

    println!(&quot;cargo:rerun-if-changed={}&quot;, linker_file);
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}
</code></pre></pre>
<p>使用 <code>build.rs</code> 来传递 <code>LINKER_FILE</code>，目前用不到。等第六章可以使用树莓派实体的时候就可以用了。</p>
<h2><a class="header" href="#观察代码运行结果" id="观察代码运行结果">观察代码运行结果</a></h2>
<p>在 <code>01_wait_forever</code> 目录下执行命令：</p>
<pre><code>&gt; make qemu
</code></pre>
<p>注意：不要更改 Makefile 中默认的 <code>rpi3</code> 为 <code>rpi4</code>，不支持。</p>
<p>输出结果：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Launching QEMU
----------------
IN: 
0x00000000:  580000c0  ldr      x0, #0x18  
0x00000004:  aa1f03e1  mov      x1, xzr // 写入 xzr 寄存器的数据被忽略，读出的数据全为0，此处为初始化寄存器 x1,x2,x3
0x00000008:  aa1f03e2  mov      x2, xzr
0x0000000c:  aa1f03e3  mov      x3, xzr
0x00000010:  58000084  ldr      x4, #0x20
0x00000014:  d61f0080  br       x4

----------------
IN: 
0x00080000:  d503205f  wfe              // wef 进入 待机模式
0x00080004:  17ffffff  b        #0x80000  // 跳转到 地址 0x00080000

----------------
IN: 
0x00000300:  d2801b05  mov      x5, #0xd8  // 从 #0xd8 移动数据到 寄存器 x5，额外工作
// mrs 状态寄存器到通用寄存器的传送指令
0x00000304:  d53800a6  mrs      x6, mpidr_el1 // mpidr_el1 寄存器在多处理器系统中，为调度提供一个额外的PE（process element）识别机制
0x00000308:  924004c6  and      x6, x6, #3 // #3的值与06相位与后的值传送到X6
0x0000030c:  d503205f  wfe      
0x00000310:  f86678a4  ldr      x4, [x5, x6, lsl #3]
0x00000314:  b4ffffc4  cbz      x4, #0x30c // CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令），此处跳转到 地址 0x0000030c

----------------
IN: 
0x00000300:  d2801b05  mov      x5, #0xd8
0x00000304:  d53800a6  mrs      x6, mpidr_el1
0x00000308:  924004c6  and      x6, x6, #3
0x0000030c:  d503205f  wfe      
0x00000310:  f86678a4  ldr      x4, [x5, x6, lsl #3]
0x00000314:  b4ffffc4  cbz      x4, #0x30c // CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令），此处跳转到 地址 0x0000030c

----------------
IN: 
0x0000030c:  d503205f  wfe      
0x00000310:  f86678a4  ldr      x4, [x5, x6, lsl #3]
0x00000314:  b4ffffc4  cbz      x4, #0x30c

----------------
IN: 
0x00000300:  d2801b05  mov      x5, #0xd8
0x00000304:  d53800a6  mrs      x6, mpidr_el1
0x00000308:  924004c6  and      x6, x6, #3
0x0000030c:  d503205f  wfe      
0x00000310:  f86678a4  ldr      x4, [x5, x6, lsl #3]
0x00000314:  b4ffffc4  cbz      x4, #0x30c // CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令），此处跳转到 地址 0x0000030c

----------------
IN: 
0x0000030c:  d503205f  wfe      
0x00000310:  f86678a4  ldr      x4, [x5, x6, lsl #3]
0x00000314:  b4ffffc4  cbz      x4, #0x30c  // CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令），此处跳转到 地址 0x0000030c
<span class="boring">}
</span></code></pre></pre>
<p>CPU 可以通过物理地址来 逐字节 访问物理内存中保存的 数据，通常以 <code>0x80000</code>开头。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
