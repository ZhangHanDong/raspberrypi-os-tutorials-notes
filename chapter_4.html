<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>04: 安全访问全局数据结构 - raspberrypi-os-tutorials-notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="arm_asm.html"><strong aria-hidden="true">2.</strong> ARM 汇编基础</a></li><li class="chapter-item expanded "><a href="chapter_0.html"><strong aria-hidden="true">3.</strong> 00: 准备工作</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">4.</strong> 01: 循环等待 </a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">5.</strong> 02: 初始化执行环境（runtime） </a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">6.</strong> 03: 硬核输出 Hello World</a></li><li class="chapter-item expanded "><a href="chapter_4.html" class="active"><strong aria-hidden="true">7.</strong> 04: 安全访问全局数据结构</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">8.</strong> 05: 驱动：GPIO 和 UART</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">raspberrypi-os-tutorials-notes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#安全访问全局数据结构" id="安全访问全局数据结构">安全访问全局数据结构</a></h1>
<blockquote>
<p>从这一章开始，我修改了 Makefile 中配置 <code>QEMU_MACHINE_TYPE = raspi4</code>，默认使用 树莓派4。</p>
</blockquote>
<p>前一章在内核初始化的时候打印 Hello World。然而并没有考虑多核的情况。</p>
<p>在前一章的打印代码中，每次打印都重新生成一个 <code>QEMUOutput</code> 实例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in src/print.rs

#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use console::interface::Write;

    bsp::console::console().write_fmt(args).unwrap();
}

// in src/bsp/raspberrypi/console.rs

struct QEMUOutput;
/// Return a reference to the console.
pub fn console() -&gt; impl console::interface::Write {
    QEMUOutput {}
}
<span class="boring">}
</span></code></pre></pre>
<p>如果想保留某些状态，比如记录写入的字符数的统计信息，我们就需要创建一个<code>QEMUOutput</code>的全局实例。因此就需要实现一个同步锁了。这一章实现了一个「假锁」作为示意。</p>
<h2><a class="header" href="#代码释意" id="代码释意">代码释意</a></h2>
<p>只记录基于第三章代码的改进，注意代码注释。</p>
<p>在 <code>src/main.rs</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn kernel_init() -&gt; ! {
    // 新增 Statistics
    use console::interface::Statistics;

    println!(&quot;[0] Hello from Rust!&quot;);

    // 新增字符计数功能
    println!(
        &quot;[1] Chars written: {}&quot;,
        bsp::console::console().chars_written()
    );

    println!(&quot;[2] Stopping here.&quot;);
    cpu::wait_forever()
}
<span class="boring">}
</span></code></pre></pre>
<p>来看一下 <code>src/console.rs</code> 代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Console interfaces.
pub mod interface {
    use core::fmt;

    // 之前是对 core 库的重导出，现在改为了自定义 Write trait
    /// Console write functions.
    pub trait Write {
        /// Write a Rust format string.
        fn write_fmt(&amp;self, args: fmt::Arguments) -&gt; fmt::Result;
    }

    // 增加用于统计写入字符数目的 trait
    /// Console statistics.
    pub trait Statistics {
        /// Return the number of characters written.
        fn chars_written(&amp;self) -&gt; usize {
            0
        }
    }

    // 这里使用了 trait 别名
    // 实际上在 main.rs 中引入了 `#![feature(trait_alias)]`
    /// Trait alias for a full-fledged console.
    pub trait All = Write + Statistics;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后看看 <code>src/bsp/raspberrypi/console.rs</code> 中的具体实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// QEMUOutputInner 用于统计字符
/// A mystical, magical device for generating QEMU output out of the void.
///
/// The mutex protected part.
struct QEMUOutputInner {
    chars_written: usize,
}

/// The main struct.
pub struct QEMUOutput {
    // 这里新增 NullLock （伪）锁来（假装）保证多核同步
    inner: NullLock&lt;QEMUOutputInner&gt;,
}

//--------------------------------------------------------------------------------------------------
// Global instances 全局实例
//--------------------------------------------------------------------------------------------------
static QEMU_OUTPUT: QEMUOutput = QEMUOutput::new();

impl QEMUOutputInner {
    const fn new() -&gt; QEMUOutputInner {
        QEMUOutputInner { chars_written: 0 }
    }

    // 获取锁以后才能调用该方法来打印并统计字符
    /// Send a character.
    fn write_char(&amp;mut self, c: char) {
        unsafe {
            // `0x3F20_1000` 为 UART0 (serial port, PL011) MMIO 地址
            core::ptr::write_volatile(0x3F20_1000 as *mut u8, c as u8);
        }

        self.chars_written += 1;
    }
}

// 此处给 QEMUOutputInner 实现 `core::fmt::Write` 

/// Implementing `core::fmt::Write` enables usage of the `format_args!` macros, which in turn are
/// used to implement the `kernel`'s `print!` and `println!` macros. By implementing `write_str()`,
/// we get `write_fmt()` automatically.
///
/// The function takes an `&amp;mut self`, so it must be implemented for the inner struct.
///
/// See [`src/print.rs`].
///
/// [`src/print.rs`]: ../../print/index.html
impl fmt::Write for QEMUOutputInner {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.chars() {
            // Convert newline to carrige return + newline.
            if c == '\n' {
                // 注意，这里调用了自定义的 write_char，在输出的时候进行统计
                self.write_char('\r')
            }

            self.write_char(c);
        }

        Ok(())
    }
}

impl QEMUOutput {
    /// Create a new instance.
    pub const fn new() -&gt; QEMUOutput {
        QEMUOutput {
            inner: NullLock::new(QEMUOutputInner::new()),
        }
    }
}

// 注意这里使用来 trait `All`
/// Return a reference to the console.
pub fn console() -&gt; &amp;'static impl console::interface::All {
    &amp;QEMU_OUTPUT
}

//------------------------------------------------------------------------------
// OS Interface Code 这里实现同步锁(Mutex)
//------------------------------------------------------------------------------
use synchronization::interface::Mutex;

// 注意这里实现的是自定义的 `Write` trait
/// Passthrough of `args` to the `core::fmt::Write` implementation, but guarded by a Mutex to
/// serialize access.
impl console::interface::Write for QEMUOutput {
    fn write_fmt(&amp;self, args: core::fmt::Arguments) -&gt; fmt::Result {
        // Fully qualified syntax for the call to `core::fmt::Write::write:fmt()` to increase
        // readability.
        // 获取锁以后，传入一个 FnOnce 闭包
        self.inner.lock(|inner| fmt::Write::write_fmt(inner, args))
    }
}

impl console::interface::Statistics for QEMUOutput {
    // 该方法在 main 中被调用
    fn chars_written(&amp;self) -&gt; usize {
        self.inner.lock(|inner| inner.chars_written)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在来看一下 <code>src/synchronization.rs</code> 中 （伪）锁的实现：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 利用 UnsafeCell 来实现锁
use core::cell::UnsafeCell;

//--------------------------------------------------------------------------------------------------
// Public Definitions
//--------------------------------------------------------------------------------------------------

/// Synchronization interfaces.
pub mod interface {

    // 实现一个 Mutex trait，任何实现了该 trait 的类型，都需要提供一个闭包来访问数据
    /// Any object implementing this trait guarantees exclusive access to the data wrapped within
    /// the Mutex for the duration of the provided closure.
    pub trait Mutex {
        /// The type of the data that is wrapped by this mutex.
        type Data;

        /// Locks the mutex and grants the closure temporary mutable access to the wrapped data.
        fn lock&lt;R&gt;(&amp;self, f: impl FnOnce(&amp;mut Self::Data) -&gt; R) -&gt; R;
    }
}

// `NullLock&lt;T&gt;` （伪）锁是为了教学目的而实现。因为我们现在是裸机编程，没有任何同步原语可以使用。

/// A pseudo-lock for teaching purposes.
///
/// In contrast to a real Mutex implementation, does not protect against concurrent access from
/// other cores to the contained data. This part is preserved for later lessons.
///
/// The lock will only be used as long as it is safe to do so, i.e. as long as the kernel is
/// executing single-threaded, aka only running on a single core with interrupts disabled.
pub struct NullLock&lt;T&gt;
where
    T: ?Sized,
{
    data: UnsafeCell&lt;T&gt;,
}

//--------------------------------------------------------------------------------------------------
// Public Code
//--------------------------------------------------------------------------------------------------

unsafe impl&lt;T&gt; Send for NullLock&lt;T&gt; where T: ?Sized + Send {}
unsafe impl&lt;T&gt; Sync for NullLock&lt;T&gt; where T: ?Sized + Send {}

impl&lt;T&gt; NullLock&lt;T&gt; {
    /// Create an instance.
    pub const fn new(data: T) -&gt; Self {
        Self {
            data: UnsafeCell::new(data),
        }
    }
}

//------------------------------------------------------------------------------
// OS Interface Code
//------------------------------------------------------------------------------

// 为`NullLock&lt;T&gt;`实现自定义的 Mutex trait
impl&lt;T&gt; interface::Mutex for NullLock&lt;T&gt; {
    type Data = T;

    fn lock&lt;R&gt;(&amp;self, f: impl FnOnce(&amp;mut Self::Data) -&gt; R) -&gt; R {
        // 在真正的锁中，将有代码封装此行，以确保每次只能给出一次此可变引用。
        // 真正的锁实现可以参考：
        //    1. https://github.com/Amanieu/parking_lot/blob/master/src/mutex.rs
        //    2. https://github.com/mvdnes/spin-rs/blob/master/src/mutex.rs
        // In a real lock, there would be code encapsulating this line that ensures that this
        // mutable reference will ever only be given out once at a time.
        let data = unsafe { &amp;mut *self.data.get() };

        f(data)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#树莓派相关背景知识" id="树莓派相关背景知识">树莓派相关背景知识</a></h2>
<p><strong>Makefile 配置文件中：</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>QEMU_RELEASE_ARGS = -serial stdio -display none
<span class="boring">}
</span></code></pre></pre>
<p>该配置将模拟的 UART0 重定向到运行 qemu 的终端的标准输入 / 输出，以便显示发送到串行线路的所有内容，并且 vm 会接收终端中键入的每个键。</p>
<p><strong>MMIO 映射外部设备</strong></p>
<p><code>memory-mapped I/O</code> 把设备寄存器映射成常规的数据空间。对它的访问与访问系统内存空间没有区别。</p>
<p>而<code>port I/O </code>把控制和数据寄存器映射到一个单独的数据空间。<code>port I/O</code> 和 <code>memory-mapped I/O</code> 相似，除了，程序必须使用特殊的指令（如 Intel x86 处理器的 <code>in</code> 和 <code>out</code> 指令）来写入或者读取设备寄存器。</p>
<p>一些更有趣的 MMIO 地址是(树莓派3)：</p>
<ul>
<li><code>0x3F003000</code>- System Timer</li>
<li><code>0x3F00B000</code>- Interrupt controller</li>
<li><code>0x3F00B880</code>- VideoCore mailbox</li>
<li><code>0x3F100000</code>- Power management</li>
<li><code>0x3F104000</code>- Random Number Generator</li>
<li><code>0x3F200000</code>- General Purpose IO controller</li>
<li><code>0x3F201000</code>- UART0 (serial port, PL011)</li>
<li><code>0x3F215000</code>- UART1 (serial port, AUX mini UART)</li>
<li><code>0x3F300000</code>- External Mass Media Controller (SD card reader)</li>
<li><code>0x3F980000</code>- Universal Serial Bus controller</li>
</ul>
<h2><a class="header" href="#小结" id="小结">小结</a></h2>
<p>从底层裸机多核视角来面对并发问题，很有意思。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
